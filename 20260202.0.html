<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>ç£æ‡¸æµ®ç£å­¸æ¨¡æ“¬ V20260202.3</title>
    <style>
        :root { --bg: #0a0a0c; --panel: #16161a; --accent: #00aaff; --text: #e0e0e0; }
        body { margin: 0; overflow: hidden; background: var(--bg); font-family: 'Segoe UI', sans-serif; color: var(--text); display: flex; }
        #sidebar { width: 300px; background: var(--panel); border-right: 1px solid #333; height: 100vh; display: flex; flex-direction: column; z-index: 10; font-size: 13px; }
        .section { padding: 15px; border-bottom: 1px solid #333; }
        h3 { margin: 0 0 12px 0; font-size: 14px; color: var(--accent); text-transform: uppercase; }
        button { background: #2a2a30; color: white; border: 1px solid #444; padding: 10px; border-radius: 4px; cursor: pointer; width: 100%; margin-bottom: 8px; transition: 0.2s; }
        button:hover { background: #3a3a45; }
        button.active { background: #d13438; border-color: #ff5f5f; }
        button.primary { background: var(--accent); border-color: #0088cc; color: #000; font-weight: bold; }
        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        label { color: #888; display: block; margin: 8px 0 4px 0; }
        input[type=range] { width: 100%; accent-color: var(--accent); }
        #canvasContainer { flex-grow: 1; position: relative; background: radial-gradient(circle, #1a1a20 0%, #0a0a0c 100%); cursor: crosshair; }
        #hud { position: absolute; top: 20px; right: 20px; background: rgba(0,0,0,0.8); padding: 15px; border-radius: 8px; border: 1px solid #444; pointer-events: none; font-family: monospace; }
        .hud-val { color: #00ff00; font-size: 16px; }
        .mag-indicator { position: absolute; pointer-events: none; border: 2px solid rgba(0, 255, 255, 0.5); border-radius: 4px; display: none; }
    </style>
</head>
<body>

<div id="sidebar">
    <div class="section">
        <h3>ç ”ç©¶å…ƒä»¶</h3>
        <div class="grid">
            <button class="primary" onclick="addObj('bar')">é•·æ¢ç£éµ</button>
            <button class="primary" onclick="addObj('cube')">æ–¹å¡Šç£éµ</button>
        </div>
        <button onclick="addObj('iron')">æ„Ÿæ‡‰éµå¡Š</button>
    </div>

    <div class="section">
        <h3>ç‰©ç†ç’°å¢ƒ</h3>
        <button id="simBtn" onclick="toggleSim()">â–¶ é–‹å§‹ç‰©ç†æ¨¡æ“¬</button>
        <button id="gravityBtn" onclick="toggleGravity()">ğŸŒ é‡åŠ›: é—œé–‰</button>
        <label>ç©ºæ°£é˜»å°¼ (é˜²æ­¢äº‚è·³)</label>
        <input type="range" id="frictionRange" min="0.85" max="0.99" step="0.01" value="0.95">
        <label>ç£åŠ›å¼·åº¦ç³»æ•¸</label>
        <input type="range" id="forceScale" min="1" max="50" value="20">
        <div class="grid">
            <button onclick="saveConfig()">ğŸ’¾ å„²å­˜è¨­å®š</button>
            <button onclick="document.getElementById('loadInput').click()">ğŸ“‚ è®€å–è¨­å®š</button>
            <input type="file" id="loadInput" style="display:none" onchange="loadConfig(event)">
        </div>
    </div>

    <div class="section">
        <h3>è§€æ¸¬èˆ‡ä½ˆå±€</h3>
        <button onclick="alignObjects()">ğŸ“ è‡ªå‹•å‚ç›´å°é½Š</button>
        <div class="grid">
            <button id="btnLines" class="primary" onclick="toggleVis('lines')">ç£åŠ›ç·š</button>
            <button id="btnGrid" onclick="toggleVis('grid')">ç£åŠ›å ´</button>
        </div>
        <button onclick="clearScene()">ğŸ—‘ æ¸…ç©ºå ´æ™¯</button>
    </div>

    <div id="propPanel" class="section" style="display:none">
        <h3>é¸å–ç‰©ä»¶å±¬æ€§</h3>
        <label>ç£å ´å¼·åº¦</label>
        <input type="range" id="strRange" min="0" max="8000" step="100" oninput="updateProp()">
        <label>å¯¬åº¦: <span id="wLabel">0</span>px</label>
        <input type="range" id="wRange" min="10" max="300" oninput="updateProp()">
        <label>é«˜åº¦: <span id="hLabel">0</span>px</label>
        <input type="range" id="hRange" min="10" max="100" oninput="updateProp()">
        <label>ç²¾ç¢ºè§’åº¦: <span id="degLabel">0</span>Â°</label>
        <input type="range" id="angRange" min="0" max="360" oninput="updateProp()">
        <div class="grid">
            <button onclick="flipObj()">ğŸ”„ ç¿»è½‰</button>
            <button onclick="delObj()" style="color:#ff4d4d">ğŸ—‘ åˆªé™¤</button>
        </div>
    </div>
</div>

<div id="canvasContainer">
    <canvas id="simCanvas"></canvas>
    <div id="hud">
        ç£å ´å¼·åº¦: <span id="valB" class="hud-val">0.00</span> G<br>
        ç³»çµ±ç©©å®šåº¦: <span id="valStable" class="hud-val">100%</span>
    </div>
</div>

<script>
    const canvas = document.getElementById('simCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    let width, height, objects = [], selected = null;
    let isSimulating = false, useGravity = false;
    let visMode = { lines: true, grid: false };
    let mouse = { x: 0, y: 0, down: false };

    function resize() {
        width = canvas.width = canvas.parentElement.clientWidth;
        height = canvas.height = canvas.parentElement.clientHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    class MagObj {
        constructor(x, y, type) {
            this.id = Date.now() + Math.random();
            this.x = x; this.y = y;
            this.type = type;
            this.w = (type === 'bar') ? 100 : 50;
            this.h = (type === 'bar') ? 24 : 50;
            this.angle = 0;
            this.strength = (type === 'iron') ? 0 : 2000;
            this.isIron = (type === 'iron');
            this.vx = 0; this.vy = 0; this.vAng = 0;
            this.mass = (this.w * this.h) / 1000;
        }

        getPoles() {
            if (this.isIron) return [];
            const cos = Math.cos(this.angle), sin = Math.sin(this.angle);
            const d = this.w * 0.45;
            return [
                { x: this.x + d * cos, y: this.y + d * sin, type: 'N' },
                { x: this.x - d * cos, y: this.y - d * sin, type: 'S' }
            ];
        }

        draw() {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.angle);
            
            const r = 4; // åœ“è§’
            if (this.isIron) {
                ctx.fillStyle = '#444'; ctx.strokeStyle = '#888';
                ctx.beginPath(); ctx.roundRect(-this.w/2, -this.h/2, this.w, this.h, r); ctx.fill(); ctx.stroke();
            } else {
                ctx.fillStyle = '#ff4444'; // N
                ctx.beginPath(); ctx.roundRect(0, -this.h/2, this.w/2, this.h, [0, r, r, 0]); ctx.fill();
                ctx.fillStyle = '#4444ff'; // S
                ctx.beginPath(); ctx.roundRect(-this.w/2, -this.h/2, this.w/2, this.h, [r, 0, 0, r]); ctx.fill();
                ctx.fillStyle = "white"; ctx.font = "bold 12px Arial"; ctx.textAlign = "center";
                ctx.fillText("N", this.w/4, 5); ctx.fillText("S", -this.w/4, 5);
            }
            if (selected === this) {
                ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 2;
                ctx.strokeRect(-this.w/2-4, -this.h/2-4, this.w+8, this.h+8);
            }
            ctx.restore();
        }
    }

    function getFieldAt(x, y, exclude = null) {
        let bx = 0, by = 0;
        
        objects.forEach(obj => {
            if (obj === exclude || obj.isIron) return;
            const poles = obj.getPoles();
            poles.forEach(p => {
                const dx = x - p.x, dy = y - p.y;
                // è»ŸåŒ–å› å­ï¼Œé˜²æ­¢è·é›¢ç‚ºé›¶æ™‚åŠ›ç„¡çª®å¤§
                const softeningFactor = 400; // 20px * 20px
                const r2 = dx*dx + dy*dy + softeningFactor;
                const invR3 = 1 / (r2 * Math.sqrt(r2));
                
                const forceMag = (p.type === 'N' ? 1 : -1) * obj.strength;
                
                bx += forceMag * dx * invR3;
                by += forceMag * dy * invR3;
            });
        });
        
        return { bx, by, m: Math.sqrt(bx*bx + by*by) };
    }

    function updatePhysics() {
        if (!isSimulating) return;

        const timeStep = 1 / 60; // å‡è¨­ 60 FPS
        const subSteps = 10; // å°‡æ¯å€‹å½±æ ¼åˆ†æˆ 10 å€‹å­æ­¥é©Ÿ
        const subTimeStep = timeStep / subSteps;

        for (let i = 0; i < subSteps; i++) {
            applyForces(subTimeStep);
            integrate(subTimeStep);
            solveCollisions();
        }
    }

    function applyForces(dt) {
        const fScale = parseFloat(document.getElementById('forceScale').value);
        const gravity = 0.15;

        objects.forEach(obj => {
            if (mouse.down && selected === obj) {
                // å¦‚æœè¢«æ»‘é¼ æ‹–å‹•ï¼Œå‰‡æ¸…é™¤æ‰€æœ‰å—åŠ›å’Œé€Ÿåº¦
                obj.vx = obj.vy = obj.vAng = 0;
                return;
            }

            let totalFx = 0, totalFy = 0, totalTorque = 0;

            // 1. ç£åŠ›
            if (!obj.isIron) {
                const poles = obj.getPoles();
                poles.forEach(p => {
                    const field = getFieldAt(p.x, p.y, obj);
                    const sign = (p.type === 'N' ? 1 : -1);
                    const fx = field.bx * sign * fScale;
                    const fy = field.by * sign * fScale;
                    
                    totalFx += fx;
                    totalFy += fy;
                    
                    const rx = p.x - obj.x, ry = p.y - obj.y;
                    totalTorque += (rx * fy - ry * fx);
                });
            } else {
                const f = getFieldAt(obj.x, obj.y);
                totalFx += f.bx * 0.5 * fScale; 
                totalFy += f.by * 0.5 * fScale;
            }

            // 2. é‡åŠ›
            if (useGravity) totalFy += gravity * obj.mass;

            // 3. åŠ é€Ÿåº¦
            obj.vx += (totalFx / obj.mass) * dt;
            obj.vy += (totalFy / obj.mass) * dt;
            obj.vAng += (totalTorque * 0.001 / obj.mass) * dt;
        });
    }

    function integrate(dt) {
        const friction = parseFloat(document.getElementById('frictionRange').value);
        const angularFriction = 0.95; // è§’åº¦é˜»å°¼å¯ä»¥ç¨å¾®ä¸åŒ

        objects.forEach(obj => {
            // æ‡‰ç”¨é˜»å°¼
            obj.vx *= friction;
            obj.vy *= friction;
            obj.vAng *= angularFriction;

            // æ›´æ–°ä½ç½®å’Œè§’åº¦
            obj.x += obj.vx * dt * 100; // ä¹˜ä»¥ 100 æ˜¯ç‚ºäº†è®“é€Ÿåº¦å–®ä½æ›´ç›´è§€
            obj.y += obj.vy * dt * 100;
            obj.angle += obj.vAng * dt * 100;

            // è™•ç†ç•«å¸ƒé‚Šç•Œ
            handleBoundaries(obj);
        });
    }

    function solveCollisions() {
        for (let i = 0; i < objects.length; i++) {
            for (let j = i + 1; j < objects.length; j++) {
                // handleCollision(objects[i], objects[j]);
                checkAndResolveCollision(objects[i], objects[j]);
            }
        }
    }

    function handleBoundaries(obj) {
        const restitution = 0.2; // æ¢å¾©ä¿‚æ•¸
        const hw = obj.w / 2, hh = obj.h / 2;
        const cos = Math.cos(obj.angle), sin = Math.sin(obj.angle);
        // ç°¡å–®ç”¨ AABB åˆ¤æ–·é‚Šç•Œï¼Œæ›´ç²¾ç¢ºéœ€è¦ OBB
        const boundW = Math.abs(hw * cos) + Math.abs(hh * sin);
        const boundH = Math.abs(hw * sin) + Math.abs(hh * cos);

        if (obj.y + boundH > height) { obj.y = height - boundH; obj.vy *= -restitution; }
        if (obj.y - boundH < 0) { obj.y = boundH; obj.vy *= -restitution; }
        if (obj.x + boundW > width) { obj.x = width - boundW; obj.vx *= -restitution; }
        if (obj.x - boundW < 0) { obj.x = boundW; obj.vx *= -restitution; }
    }

    // =================================================================
    // åˆ†é›¢è»¸å®šç† (SAT) ç¢°æ’æª¢æ¸¬
    // =================================================================
    function checkAndResolveCollision(obj1, obj2) {
        const vertices1 = getVertices(obj1);
        const vertices2 = getVertices(obj2);
        const axes = getAxes(vertices1).concat(getAxes(vertices2));

        let minOverlap = Infinity;
        let smallestAxis = null;

        for (let i = 0; i < axes.length; i++) {
            const axis = axes[i];
            const p1 = project(vertices1, axis);
            const p2 = project(vertices2, axis);

            const overlap = Math.min(p1.max, p2.max) - Math.max(p1.min, p2.min);
            if (overlap < 0) {
                // åœ¨é€™å€‹è»¸ä¸Šæ‰¾åˆ°äº†é–“éš™ï¼Œæ²’æœ‰ç¢°æ’
                return;
            }

            if (overlap < minOverlap) {
                minOverlap = overlap;
                smallestAxis = axis;
            }
        }

        // å¦‚æœæ‰€æœ‰è»¸éƒ½é‡ç–Šï¼Œå‰‡ç™¼ç”Ÿäº†ç¢°æ’
        // è¨ˆç®—æ¨é–‹å‘é‡ (MTV)
        const mtv = smallestAxis;
        const centerVec = { x: obj2.x - obj1.x, y: obj2.y - obj1.y };
        if (dot(centerVec, mtv) < 0) {
            mtv.x = -mtv.x;
            mtv.y = -mtv.y;
        }
        
        // åˆ†é›¢ç‰©é«”
        const pushX = mtv.x * minOverlap * 0.5;
        const pushY = mtv.y * minOverlap * 0.5;
        
        obj1.x -= pushX;
        obj1.y -= pushY;
        obj2.x += pushX;
        obj2.y += pushY;

        // ç¢°æ’å¾Œçš„ç°¡æ˜“é€Ÿåº¦éŸ¿æ‡‰
        const restitution = 0.1; // ç¢°æ’å½ˆæ€§
        const totalMass = obj1.mass + obj2.mass;
        const vdx = obj2.vx - obj1.vx;
        const vdy = obj2.vy - obj1.vy;
        const impulse = (vdx * mtv.x + vdy * mtv.y) * 1.1; // 1.1 æ˜¯ä¸€å€‹å°çš„å¢ç›Šï¼Œç¢ºä¿åˆ†é›¢

        if (impulse > 0) {
             const impulseX = mtv.x * impulse;
             const impulseY = mtv.y * impulse;
             obj1.vx += impulseX * (obj2.mass / totalMass) * restitution;
             obj1.vy += impulseY * (obj2.mass / totalMass) * restitution;
             obj2.vx -= impulseX * (obj1.mass / totalMass) * restitution;
             obj2.vy -= impulseY * (obj1.mass / totalMass) * restitution;
        }
    }

    function getVertices(obj) {
        const hw = obj.w / 2;
        const hh = obj.h / 2;
        const cos = Math.cos(obj.angle);
        const sin = Math.sin(obj.angle);
        
        const corners = [
            { x: -hw, y: -hh }, { x: hw, y: -hh },
            { x: hw, y: hh },   { x: -hw, y: hh }
        ];

        return corners.map(p => ({
            x: obj.x + p.x * cos - p.y * sin,
            y: obj.y + p.x * sin + p.y * cos
        }));
    }

    function getAxes(vertices) {
        const axes = [];
        for (let i = 0; i < vertices.length; i++) {
            const p1 = vertices[i];
            const p2 = vertices[i + 1 === vertices.length ? 0 : i + 1];
            const edge = { x: p1.x - p2.x, y: p1.y - p2.y };
            const normal = { x: -edge.y, y: edge.x };
            axes.push(normalize(normal));
        }
        return axes;
    }

    function project(vertices, axis) {
        let min = dot(vertices[0], axis);
        let max = min;
        for (let i = 1; i < vertices.length; i++) {
            const p = dot(vertices[i], axis);
            if (p < min) {
                min = p;
            } else if (p > max) {
                max = p;
            }
        }
        return { min, max };
    }

    function dot(v1, v2) {
        return v1.x * v2.x + v1.y * v2.y;
    }

    function normalize(v) {
        const len = Math.sqrt(v.x * v.x + v.y * v.y);
        if (len === 0) return {x: 0, y: 0};
        return { x: v.x / len, y: v.y / len };
    }
    // =================================================================

    function handleCollision(obj1, obj2) {
        // é€™å€‹å‡½æ•¸ç¾åœ¨è¢« checkAndResolveCollision å–ä»£
        // ç‚ºäº†å®‰å…¨èµ·è¦‹ä¿ç•™ä¸€å€‹ç©ºå‡½æ•¸
    }

    function drawFieldLines() {
        const step = 20;
        ctx.lineWidth = 1;
        objects.forEach(obj => {
            if (obj.isIron) return;
            const nPole = obj.getPoles()[0];
            for (let i = 0; i < 12; i++) {
                let cx = nPole.x, cy = nPole.y;
                const ang = (i / 12) * Math.PI * 2 + obj.angle;
                cx += Math.cos(ang) * 5; cy += Math.sin(ang) * 5;
                
                ctx.beginPath(); ctx.moveTo(cx, cy);
                ctx.strokeStyle = `rgba(0, 170, 255, ${isSimulating ? 0.2 : 0.4})`;
                for (let s = 0; s < 50; s++) {
                    const f = getFieldAt(cx, cy);
                    if (f.m < 0.001) break;
                    cx += (f.bx / f.m) * 10; cy += (f.by / f.m) * 10;
                    ctx.lineTo(cx, cy);
                    // æ’åˆ° S æ¥µåœæ­¢
                    let hit = false;
                    objects.forEach(o => { if(!o.isIron && Math.hypot(cx-o.getPoles()[1].x, cy-o.getPoles()[1].y) < 8) hit=true; });
                    if (hit || cx<0 || cx>width || cy<0 || cy>height) break;
                }
                ctx.stroke();
            }
        });
    }

    function loop() {
        updatePhysics();
        ctx.fillStyle = '#0a0a0c'; ctx.fillRect(0, 0, width, height);
        if (visMode.lines) drawFieldLines();
        objects.forEach(obj => obj.draw());
        
        // HUD æ›´æ–°
        const f = getFieldAt(mouse.x, mouse.y);
        document.getElementById('valB').innerText = (f.m * 100).toFixed(2);
        requestAnimationFrame(loop);
    }

    // --- å¯¦é©—åŠŸèƒ½ ---
    window.addObj = (type) => {
        const obj = new MagObj(width/2, height/2, type);
        objects.push(obj);
        select(obj);
    };

    window.alignObjects = () => {
        if (objects.length < 2) return;
        const centerX = width / 2;
        objects.forEach((obj, i) => {
            obj.x = centerX;
            obj.y = height / 2 - 100 + i * 150; // å‚ç›´æ’åˆ—
            obj.vx = 0; obj.vAng = 0;
            // å¦‚æœæ˜¯åšç ”ç©¶ï¼Œé€šå¸¸è®“ç£éµæ°´å¹³æ”¾ç½®
            obj.angle = 0; 
        });
    };

    function select(obj) {
        selected = obj;
        const panel = document.getElementById('propPanel');
        if (obj) {
            panel.style.display = 'block';
            document.getElementById('strRange').value = obj.strength;
            document.getElementById('wRange').value = obj.w;
            document.getElementById('hRange').value = obj.h;
            document.getElementById('wLabel').innerText = obj.w + 'px';
            document.getElementById('hLabel').innerText = obj.h + 'px';
            const angleDeg = Math.round(obj.angle * 180 / Math.PI) % 360;
            document.getElementById('angRange').value = angleDeg;
            document.getElementById('degLabel').innerText = angleDeg + 'Â°';
        } else { panel.style.display = 'none'; }
    }

    window.updateProp = () => {
        if (!selected) return;
        selected.strength = parseInt(document.getElementById('strRange').value);
        selected.w = parseInt(document.getElementById('wRange').value);
        selected.h = parseInt(document.getElementById('hRange').value);
        selected.angle = (parseInt(document.getElementById('angRange').value) * Math.PI / 180);
        
        // æ›´æ–°æ¨™ç±¤
        document.getElementById('wLabel').innerText = selected.w + 'px';
        document.getElementById('hLabel').innerText = selected.h + 'px';
        document.getElementById('degLabel').innerText = document.getElementById('angRange').value + 'Â°';
        
        // æ›´æ–°è³ªé‡
        selected.mass = (selected.w * selected.h) / 1000;
    };

    window.toggleGravity = () => {
        useGravity = !useGravity;
        document.getElementById('gravityBtn').innerText = useGravity ? "ğŸŒ é‡åŠ›: é–‹å•Ÿ" : "ğŸŒ é‡åŠ›: é—œé–‰";
        document.getElementById('gravityBtn').classList.toggle('primary');
    };

    window.toggleSim = () => {
        isSimulating = !isSimulating;
        document.getElementById('simBtn').innerText = isSimulating ? "ğŸ›‘ åœæ­¢æ¨¡æ“¬" : "â–¶ é–‹å§‹æ¨¡æ“¬";
        document.getElementById('simBtn').classList.toggle('active');
    };

    window.flipObj = () => { if(selected) { selected.angle += Math.PI; updateProp(); } };
    window.delObj = () => { objects = objects.filter(o => o !== selected); select(null); };
    window.clearScene = () => { objects = []; select(null); };
    window.toggleVis = (t) => { visMode[t] = !visMode[t]; document.getElementById(t==='lines'?'btnLines':'btnGrid').classList.toggle('primary'); };

    canvas.onmousedown = (e) => {
        mouse.down = true;
        const hit = objects.find(o => Math.hypot(o.x - mouse.x, o.y - mouse.y) < 40);
        select(hit || null);
    };
    window.onmousemove = (e) => {
        const rect = canvas.getBoundingClientRect();
        mouse.x = e.clientX - rect.left; mouse.y = e.clientY - rect.top;
        if (mouse.down && selected) { selected.x = mouse.x; selected.y = mouse.y; selected.vx = 0; selected.vy = 0; }
    };
    window.onmouseup = () => mouse.down = false;

    // --- å­˜æª”/è®€æª”åŠŸèƒ½ ---
    window.saveConfig = () => {
        const config = {
            objects: objects.map(o => ({
                x: o.x, y: o.y,
                type: o.type,
                w: o.w, h: o.h,
                angle: o.angle,
                strength: o.strength,
                isIron: o.isIron
            })),
            settings: {
                useGravity: useGravity,
                friction: document.getElementById('frictionRange').value,
                forceScale: document.getElementById('forceScale').value
            }
        };
        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(config, null, 2));
        const downloadAnchorNode = document.createElement('a');
        downloadAnchorNode.setAttribute("href", dataStr);
        downloadAnchorNode.setAttribute("download", "magnet_config.json");
        document.body.appendChild(downloadAnchorNode);
        downloadAnchorNode.click();
        downloadAnchorNode.remove();
    };

    window.loadConfig = (event) => {
        
        console.log("Hi Noah There is Loading config...");

        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const config = JSON.parse(e.target.result);
                
                // è¼‰å…¥è¨­å®š
                document.getElementById('frictionRange').value = config.settings.friction;
                document.getElementById('forceScale').value = config.settings.forceScale;
                if (useGravity !== config.settings.useGravity) {
                    toggleGravity();
                }

                // è¼‰å…¥ç‰©ä»¶
                objects = [];
                config.objects.forEach(objData => {
                    const newObj = new MagObj(objData.x, objData.y, objData.type);
                    newObj.w = objData.w;
                    newObj.h = objData.h;
                    newObj.angle = objData.angle;
                    newObj.strength = objData.strength;
                    newObj.isIron = objData.isIron;
                    newObj.mass = (newObj.w * newObj.h) / 1000;
                    objects.push(newObj);
                });
                select(null); // æ¸…é™¤é¸å–
            } catch (err) {
                alert("è®€å–è¨­å®šæª”å¤±æ•—ï¼Œè«‹ç¢ºèªæª”æ¡ˆæ ¼å¼æ˜¯å¦æ­£ç¢ºã€‚");
                console.error(err);
            }
        };
        reader.readAsText(file);
        event.target.value = ''; // é‡è¨­ inputï¼Œä»¥ä¾¿å¯ä»¥å†æ¬¡è¼‰å…¥åŒä¸€å€‹æª”æ¡ˆ
    };

    loop();
</script>
</body>
</html>